import { z } from 'zod'
import { executeGraphQL } from '../../utils/graphql'

// Query to fetch content with raw block data for analysis
const BLOCKS_ANALYSIS_QUERY = `
  query BlocksAnalysis($first: Int = 50) {
    posts(first: $first) {
      nodes {
        content(format: RAW)
      }
    }
    pages(first: $first) {
      nodes {
        content(format: RAW)
      }
    }
  }
`

interface BlockInfo {
  name: string
  namespace: string
  blockName: string
  count: number
  sampleAttributes?: Record<string, unknown>
}

// Extract blocks from raw WordPress content
function extractBlocksFromContent(rawContent: string | null | undefined): Array<{
  fullName: string
  namespace: string
  blockName: string
  attributes?: Record<string, unknown>
}> {
  if (!rawContent) return []

  const blockRegex = /<!-- wp:([a-z0-9-]+\/)?([a-z0-9-]+)(?:\s+(\{[^}]*\}))?\s*\/?-->/g
  const blocks: Array<{
    fullName: string
    namespace: string
    blockName: string
    attributes?: Record<string, unknown>
  }> = []
  let match

  while ((match = blockRegex.exec(rawContent)) !== null) {
    const namespace = match[1] ? match[1].slice(0, -1) : 'core'
    const blockName = match[2]
    const attributesJson = match[3]

    let attributes: Record<string, unknown> | undefined
    if (attributesJson) {
      try {
        attributes = JSON.parse(attributesJson)
      } catch {
        // Invalid JSON, skip attributes
      }
    }

    blocks.push({
      fullName: `${namespace}/${blockName}`,
      namespace,
      blockName,
      attributes
    })
  }

  return blocks
}

function toPascalCase(str: string): string {
  return str
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

function generateCoreBlockRenderer(blockName: string): { filename: string, content: string } | null {
  const componentName = `Block${toPascalCase(blockName)}`

  // Core block renderers
  const coreRenderers: Record<string, string> = {
    paragraph: `<script setup lang="ts">
/**
 * Core Paragraph Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    align?: 'left' | 'center' | 'right'
    dropCap?: boolean
    fontSize?: string
    backgroundColor?: string
    textColor?: string
  }
  innerHTML?: string
}

defineProps<Props>()
</script>

<template>
  <p
    class="wp-block-paragraph"
    :class="{
      'has-drop-cap': attrs?.dropCap,
      [\`has-text-align-\${attrs?.align}\`]: attrs?.align,
      [\`has-\${attrs?.fontSize}-font-size\`]: attrs?.fontSize,
      [\`has-\${attrs?.backgroundColor}-background-color\`]: attrs?.backgroundColor,
      [\`has-\${attrs?.textColor}-color\`]: attrs?.textColor
    }"
    v-html="innerHTML"
  />
</template>

<style scoped>
.wp-block-paragraph {
  margin-bottom: 1rem;
}

.has-drop-cap::first-letter {
  font-size: 3.5em;
  float: left;
  line-height: 1;
  margin-right: 0.1em;
}

.has-text-align-center {
  text-align: center;
}

.has-text-align-right {
  text-align: right;
}
</style>`,

    heading: `<script setup lang="ts">
/**
 * Core Heading Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    level?: 1 | 2 | 3 | 4 | 5 | 6
    textAlign?: 'left' | 'center' | 'right'
  }
  innerHTML?: string
}

const props = withDefaults(defineProps<Props>(), {
  attrs: () => ({ level: 2 })
})
</script>

<template>
  <component
    :is="\`h\${attrs?.level || 2}\`"
    class="wp-block-heading"
    :class="{ [\`has-text-align-\${attrs?.textAlign}\`]: attrs?.textAlign }"
    v-html="innerHTML"
  />
</template>

<style scoped>
.wp-block-heading {
  margin-top: 1.5rem;
  margin-bottom: 1rem;
}

.has-text-align-center {
  text-align: center;
}

.has-text-align-right {
  text-align: right;
}
</style>`,

    image: `<script setup lang="ts">
/**
 * Core Image Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    id?: number
    url?: string
    alt?: string
    caption?: string
    width?: number
    height?: number
    sizeSlug?: string
    align?: 'left' | 'center' | 'right' | 'wide' | 'full'
    linkDestination?: string
    href?: string
  }
}

defineProps<Props>()
</script>

<template>
  <figure
    class="wp-block-image"
    :class="{
      [\`align\${attrs?.align}\`]: attrs?.align,
      [\`size-\${attrs?.sizeSlug}\`]: attrs?.sizeSlug
    }"
  >
    <component
      :is="attrs?.href ? 'a' : 'div'"
      :href="attrs?.href"
      class="image-wrapper"
    >
      <img
        :src="attrs?.url"
        :alt="attrs?.alt || ''"
        :width="attrs?.width"
        :height="attrs?.height"
        loading="lazy"
      />
    </component>
    <figcaption v-if="attrs?.caption" v-html="attrs.caption" />
  </figure>
</template>

<style scoped>
.wp-block-image {
  margin: 1.5rem 0;
}

.wp-block-image img {
  max-width: 100%;
  height: auto;
}

.wp-block-image.aligncenter {
  text-align: center;
}

.wp-block-image.alignleft {
  float: left;
  margin-right: 1rem;
}

.wp-block-image.alignright {
  float: right;
  margin-left: 1rem;
}

.wp-block-image.alignwide {
  width: calc(100% + 4rem);
  margin-left: -2rem;
  margin-right: -2rem;
}

.wp-block-image.alignfull {
  width: 100vw;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);
}

.wp-block-image figcaption {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: #666;
  text-align: center;
}
</style>`,

    list: `<script setup lang="ts">
/**
 * Core List Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    ordered?: boolean
    start?: number
    reversed?: boolean
  }
  innerHTML?: string
}

defineProps<Props>()
</script>

<template>
  <component
    :is="attrs?.ordered ? 'ol' : 'ul'"
    class="wp-block-list"
    :start="attrs?.start"
    :reversed="attrs?.reversed"
    v-html="innerHTML"
  />
</template>

<style scoped>
.wp-block-list {
  margin: 1rem 0;
  padding-left: 1.5rem;
}

.wp-block-list :deep(li) {
  margin-bottom: 0.25rem;
}
</style>`,

    quote: `<script setup lang="ts">
/**
 * Core Quote Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    citation?: string
    align?: 'left' | 'center' | 'right'
  }
  innerHTML?: string
}

defineProps<Props>()
</script>

<template>
  <blockquote
    class="wp-block-quote"
    :class="{ [\`has-text-align-\${attrs?.align}\`]: attrs?.align }"
  >
    <div v-html="innerHTML" />
    <cite v-if="attrs?.citation" v-html="attrs.citation" />
  </blockquote>
</template>

<style scoped>
.wp-block-quote {
  margin: 1.5rem 0;
  padding: 1rem 1.5rem;
  border-left: 4px solid #333;
  font-style: italic;
}

.wp-block-quote cite {
  display: block;
  margin-top: 0.5rem;
  font-size: 0.875rem;
  font-style: normal;
  color: #666;
}

.wp-block-quote cite::before {
  content: '— ';
}
</style>`,

    code: `<script setup lang="ts">
/**
 * Core Code Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    language?: string
  }
  innerHTML?: string
}

defineProps<Props>()
</script>

<template>
  <pre class="wp-block-code"><code :class="attrs?.language ? \`language-\${attrs.language}\` : ''" v-html="innerHTML" /></pre>
</template>

<style scoped>
.wp-block-code {
  margin: 1.5rem 0;
  padding: 1rem;
  background: #f5f5f5;
  border-radius: 4px;
  overflow-x: auto;
}

.wp-block-code code {
  font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
  font-size: 0.875rem;
  line-height: 1.5;
}
</style>`,

    buttons: `<script setup lang="ts">
/**
 * Core Buttons Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    layout?: {
      type?: string
      justifyContent?: string
    }
  }
}

defineProps<Props>()
</script>

<template>
  <div
    class="wp-block-buttons"
    :class="{
      [\`is-content-justification-\${attrs?.layout?.justifyContent}\`]: attrs?.layout?.justifyContent
    }"
  >
    <slot />
  </div>
</template>

<style scoped>
.wp-block-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin: 1rem 0;
}

.is-content-justification-center {
  justify-content: center;
}

.is-content-justification-right {
  justify-content: flex-end;
}

.is-content-justification-space-between {
  justify-content: space-between;
}
</style>`,

    button: `<script setup lang="ts">
/**
 * Core Button Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    url?: string
    text?: string
    linkTarget?: string
    rel?: string
    backgroundColor?: string
    textColor?: string
    style?: {
      border?: { radius?: string }
    }
  }
}

defineProps<Props>()
</script>

<template>
  <div class="wp-block-button">
    <a
      v-if="attrs?.url"
      :href="attrs.url"
      :target="attrs?.linkTarget"
      :rel="attrs?.rel"
      class="wp-block-button__link"
      :class="{
        [\`has-\${attrs?.backgroundColor}-background-color\`]: attrs?.backgroundColor,
        [\`has-\${attrs?.textColor}-color\`]: attrs?.textColor
      }"
      :style="attrs?.style?.border?.radius ? { borderRadius: attrs.style.border.radius } : undefined"
    >
      {{ attrs?.text }}
    </a>
    <span v-else class="wp-block-button__link">
      {{ attrs?.text }}
    </span>
  </div>
</template>

<style scoped>
.wp-block-button__link {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  background: #333;
  color: white;
  text-decoration: none;
  border-radius: 4px;
  transition: opacity 0.2s;
}

.wp-block-button__link:hover {
  opacity: 0.9;
}
</style>`,

    gallery: `<script setup lang="ts">
/**
 * Core Gallery Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    columns?: number
    imageCrop?: boolean
    linkTo?: string
    ids?: number[]
    images?: Array<{
      url: string
      alt?: string
      caption?: string
      id?: number
    }>
  }
}

withDefaults(defineProps<Props>(), {
  attrs: () => ({ columns: 3 })
})
</script>

<template>
  <figure
    class="wp-block-gallery"
    :class="\`columns-\${attrs?.columns || 3}\`"
  >
    <ul class="gallery-items">
      <li
        v-for="(image, index) in attrs?.images"
        :key="image.id || index"
        class="gallery-item"
      >
        <figure>
          <img
            :src="image.url"
            :alt="image.alt || ''"
            loading="lazy"
          />
          <figcaption v-if="image.caption" v-html="image.caption" />
        </figure>
      </li>
    </ul>
    <slot />
  </figure>
</template>

<style scoped>
.wp-block-gallery {
  margin: 1.5rem 0;
}

.gallery-items {
  display: grid;
  gap: 0.5rem;
  list-style: none;
  padding: 0;
  margin: 0;
}

.columns-2 .gallery-items {
  grid-template-columns: repeat(2, 1fr);
}

.columns-3 .gallery-items {
  grid-template-columns: repeat(3, 1fr);
}

.columns-4 .gallery-items {
  grid-template-columns: repeat(4, 1fr);
}

.gallery-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.gallery-item figcaption {
  font-size: 0.75rem;
  color: #666;
  padding: 0.25rem;
}

@media (max-width: 768px) {
  .columns-3 .gallery-items,
  .columns-4 .gallery-items {
    grid-template-columns: repeat(2, 1fr);
  }
}
</style>`,

    embed: `<script setup lang="ts">
/**
 * Core Embed Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    url?: string
    type?: string
    providerNameSlug?: string
    responsive?: boolean
    caption?: string
  }
  innerHTML?: string
}

defineProps<Props>()
</script>

<template>
  <figure
    class="wp-block-embed"
    :class="{
      [\`is-type-\${attrs?.type}\`]: attrs?.type,
      [\`is-provider-\${attrs?.providerNameSlug}\`]: attrs?.providerNameSlug,
      'wp-embed-aspect-16-9': attrs?.responsive
    }"
  >
    <div class="wp-block-embed__wrapper" v-html="innerHTML" />
    <figcaption v-if="attrs?.caption" v-html="attrs.caption" />
  </figure>
</template>

<style scoped>
.wp-block-embed {
  margin: 1.5rem 0;
}

.wp-block-embed__wrapper {
  position: relative;
}

.wp-embed-aspect-16-9 .wp-block-embed__wrapper {
  padding-top: 56.25%;
}

.wp-embed-aspect-16-9 .wp-block-embed__wrapper :deep(iframe) {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.wp-block-embed figcaption {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: #666;
  text-align: center;
}
</style>`,

    separator: `<script setup lang="ts">
/**
 * Core Separator Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    className?: string
  }
}

defineProps<Props>()
</script>

<template>
  <hr
    class="wp-block-separator"
    :class="attrs?.className"
  />
</template>

<style scoped>
.wp-block-separator {
  margin: 2rem auto;
  border: none;
  border-top: 2px solid #ddd;
  width: 100px;
}

.wp-block-separator.is-style-wide {
  width: 100%;
}

.wp-block-separator.is-style-dots {
  border: none;
  text-align: center;
  width: 100%;
}

.wp-block-separator.is-style-dots::before {
  content: '···';
  letter-spacing: 1em;
  font-size: 1.5rem;
  color: #999;
}
</style>`,

    spacer: `<script setup lang="ts">
/**
 * Core Spacer Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    height?: string
  }
}

defineProps<Props>()
</script>

<template>
  <div
    class="wp-block-spacer"
    :style="{ height: attrs?.height || '100px' }"
    aria-hidden="true"
  />
</template>

<style scoped>
.wp-block-spacer {
  display: block;
}
</style>`,

    columns: `<script setup lang="ts">
/**
 * Core Columns Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    verticalAlignment?: 'top' | 'center' | 'bottom'
    isStackedOnMobile?: boolean
  }
}

defineProps<Props>()
</script>

<template>
  <div
    class="wp-block-columns"
    :class="{
      [\`are-vertically-aligned-\${attrs?.verticalAlignment}\`]: attrs?.verticalAlignment,
      'is-not-stacked-on-mobile': attrs?.isStackedOnMobile === false
    }"
  >
    <slot />
  </div>
</template>

<style scoped>
.wp-block-columns {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  margin: 1.5rem 0;
}

.are-vertically-aligned-top {
  align-items: flex-start;
}

.are-vertically-aligned-center {
  align-items: center;
}

.are-vertically-aligned-bottom {
  align-items: flex-end;
}

@media (max-width: 768px) {
  .wp-block-columns:not(.is-not-stacked-on-mobile) {
    flex-direction: column;
  }
}
</style>`,

    column: `<script setup lang="ts">
/**
 * Core Column Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    width?: string
    verticalAlignment?: 'top' | 'center' | 'bottom'
  }
}

defineProps<Props>()
</script>

<template>
  <div
    class="wp-block-column"
    :class="{
      [\`is-vertically-aligned-\${attrs?.verticalAlignment}\`]: attrs?.verticalAlignment
    }"
    :style="attrs?.width ? { flexBasis: attrs.width } : undefined"
  >
    <slot />
  </div>
</template>

<style scoped>
.wp-block-column {
  flex: 1;
  min-width: 0;
}

.is-vertically-aligned-top {
  align-self: flex-start;
}

.is-vertically-aligned-center {
  align-self: center;
}

.is-vertically-aligned-bottom {
  align-self: flex-end;
}
</style>`,

    group: `<script setup lang="ts">
/**
 * Core Group Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    tagName?: string
    layout?: {
      type?: string
      contentSize?: string
      wideSize?: string
    }
    backgroundColor?: string
    textColor?: string
  }
}

defineProps<Props>()
</script>

<template>
  <component
    :is="attrs?.tagName || 'div'"
    class="wp-block-group"
    :class="{
      [\`has-\${attrs?.backgroundColor}-background-color\`]: attrs?.backgroundColor,
      [\`has-\${attrs?.textColor}-color\`]: attrs?.textColor
    }"
    :style="{
      maxWidth: attrs?.layout?.contentSize,
      '--wide-size': attrs?.layout?.wideSize
    }"
  >
    <slot />
  </component>
</template>

<style scoped>
.wp-block-group {
  margin: 1.5rem 0;
}
</style>`,

    cover: `<script setup lang="ts">
/**
 * Core Cover Block Renderer
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: {
    url?: string
    alt?: string
    hasParallax?: boolean
    isRepeated?: boolean
    dimRatio?: number
    overlayColor?: string
    minHeight?: number
    minHeightUnit?: string
    contentPosition?: string
  }
}

defineProps<Props>()
</script>

<template>
  <div
    class="wp-block-cover"
    :class="{
      'has-parallax': attrs?.hasParallax,
      'is-repeated': attrs?.isRepeated
    }"
    :style="{
      backgroundImage: attrs?.url ? \`url(\${attrs.url})\` : undefined,
      minHeight: attrs?.minHeight ? \`\${attrs.minHeight}\${attrs?.minHeightUnit || 'px'}\` : undefined
    }"
  >
    <span
      v-if="attrs?.dimRatio"
      class="wp-block-cover__background"
      :class="attrs?.overlayColor ? \`has-\${attrs.overlayColor}-background-color\` : ''"
      :style="{ opacity: (attrs.dimRatio || 50) / 100 }"
    />
    <div class="wp-block-cover__inner-container">
      <slot />
    </div>
  </div>
</template>

<style scoped>
.wp-block-cover {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 430px;
  padding: 2rem;
  background-size: cover;
  background-position: center;
  margin: 1.5rem 0;
}

.wp-block-cover.has-parallax {
  background-attachment: fixed;
}

.wp-block-cover.is-repeated {
  background-size: auto;
  background-repeat: repeat;
}

.wp-block-cover__background {
  position: absolute;
  inset: 0;
  background: #000;
}

.wp-block-cover__inner-container {
  position: relative;
  z-index: 1;
  color: white;
  text-align: center;
  width: 100%;
}
</style>`
  }

  const template = coreRenderers[blockName]
  if (!template) return null

  return {
    filename: `components/blocks/${componentName}.vue`,
    content: template
  }
}

function generateGenericBlockRenderer(block: BlockInfo): { filename: string, content: string } {
  const componentName = `Block${toPascalCase(block.namespace)}${toPascalCase(block.blockName)}`

  // Generate props interface based on sample attributes
  let propsInterface = 'Record<string, unknown>'
  if (block.sampleAttributes && Object.keys(block.sampleAttributes).length > 0) {
    const attrs = Object.entries(block.sampleAttributes)
      .map(([key, value]) => {
        const type = typeof value === 'string'
          ? 'string'
          : typeof value === 'number'
            ? 'number'
            : typeof value === 'boolean'
              ? 'boolean'
              : 'unknown'
        return `    ${key}?: ${type}`
      })
      .join('\n')
    propsInterface = `{\n${attrs}\n  }`
  }

  const content = `<script setup lang="ts">
/**
 * ${block.name} Block Renderer
 * Namespace: ${block.namespace}
 * Generated by WPNuxt MCP
 */

interface Props {
  attrs?: ${propsInterface}
  innerHTML?: string
}

defineProps<Props>()
</script>

<template>
  <div class="wp-block-${block.namespace}-${block.blockName}">
    <!-- Custom block: ${block.name} -->
    <!-- Implement custom rendering logic based on your block's structure -->
    <div v-if="innerHTML" v-html="innerHTML" />
    <slot v-else />
  </div>
</template>

<style scoped>
.wp-block-${block.namespace}-${block.blockName} {
  margin: 1rem 0;
}
</style>
`

  return {
    filename: `components/blocks/${componentName}.vue`,
    content
  }
}

function generateBlockRenderer(): { filename: string, content: string } {
  const content = `<script setup lang="ts">
/**
 * Block Renderer Component
 * Dynamically renders Gutenberg blocks
 * Generated by WPNuxt MCP
 */

interface Block {
  name: string
  attrs?: Record<string, unknown>
  innerHTML?: string
  innerBlocks?: Block[]
}

interface Props {
  blocks: Block[]
}

defineProps<Props>()

// Map block names to components
const blockComponents: Record<string, string> = {
  'core/paragraph': 'BlockParagraph',
  'core/heading': 'BlockHeading',
  'core/image': 'BlockImage',
  'core/list': 'BlockList',
  'core/quote': 'BlockQuote',
  'core/code': 'BlockCode',
  'core/buttons': 'BlockButtons',
  'core/button': 'BlockButton',
  'core/gallery': 'BlockGallery',
  'core/embed': 'BlockEmbed',
  'core/separator': 'BlockSeparator',
  'core/spacer': 'BlockSpacer',
  'core/columns': 'BlockColumns',
  'core/column': 'BlockColumn',
  'core/group': 'BlockGroup',
  'core/cover': 'BlockCover'
  // Add custom block mappings here
}

function getComponentName(blockName: string): string | null {
  return blockComponents[blockName] || null
}
</script>

<template>
  <div class="block-renderer">
    <template v-for="(block, index) in blocks" :key="index">
      <component
        v-if="getComponentName(block.name)"
        :is="getComponentName(block.name)"
        :attrs="block.attrs"
        :innerHTML="block.innerHTML"
      >
        <!-- Render inner blocks recursively -->
        <BlockRenderer
          v-if="block.innerBlocks?.length"
          :blocks="block.innerBlocks"
        />
      </component>

      <!-- Fallback for unknown blocks -->
      <div
        v-else
        class="wp-block-unknown"
        :data-block-name="block.name"
        v-html="block.innerHTML"
      />
    </template>
  </div>
</template>

<style scoped>
.block-renderer {
  width: 100%;
}

.wp-block-unknown {
  margin: 1rem 0;
}
</style>
`

  return {
    filename: 'components/blocks/BlockRenderer.vue',
    content
  }
}

export default defineMcpTool({
  description: 'Generate Vue components for rendering Gutenberg blocks. Analyzes blocks in use and creates appropriate renderer components.',
  inputSchema: {
    includeCore: z.boolean().optional().describe('Include renderers for core blocks (default: true)'),
    includeCustom: z.boolean().optional().describe('Include renderers for custom/plugin blocks (default: true)'),
    sampleSize: z.number().min(10).max(100).optional().describe('Number of posts/pages to scan for blocks (default: 50)')
  },
  async handler({ includeCore = true, includeCustom = true, sampleSize = 50 }) {
    // Fetch content to analyze blocks
    const result = await executeGraphQL<{
      posts: { nodes: Array<{ content?: string }> }
      pages: { nodes: Array<{ content?: string }> }
    }>(BLOCKS_ANALYSIS_QUERY, { first: sampleSize })

    if (result.errors) {
      return textResult(`GraphQL Error: ${result.errors.map(e => e.message).join(', ')}`)
    }

    // Combine all content
    const allContent = [
      ...(result.data?.posts.nodes || []),
      ...(result.data?.pages.nodes || [])
    ]

    // Extract and analyze blocks
    const blockMap = new Map<string, BlockInfo>()

    allContent.forEach((item) => {
      const blocks = extractBlocksFromContent(item.content)

      blocks.forEach((block) => {
        const existing = blockMap.get(block.fullName)
        if (existing) {
          existing.count++
        } else {
          blockMap.set(block.fullName, {
            name: block.fullName,
            namespace: block.namespace,
            blockName: block.blockName,
            count: 1,
            sampleAttributes: block.attributes
          })
        }
      })
    })

    const detectedBlocks = Array.from(blockMap.values())
      .sort((a, b) => b.count - a.count)

    const generatedComponents: Array<{ filename: string, content: string, description: string }> = []

    // Generate main BlockRenderer component
    const blockRenderer = generateBlockRenderer()
    generatedComponents.push({
      ...blockRenderer,
      description: 'Main block renderer component that dynamically renders blocks'
    })

    // Generate core block renderers
    if (includeCore) {
      const coreBlocks = detectedBlocks.filter(b => b.namespace === 'core')
      for (const block of coreBlocks) {
        const renderer = generateCoreBlockRenderer(block.blockName)
        if (renderer) {
          generatedComponents.push({
            ...renderer,
            description: `Core ${block.blockName} block renderer (used ${block.count} times)`
          })
        }
      }
    }

    // Generate custom block renderers
    if (includeCustom) {
      const customBlocks = detectedBlocks.filter(b => b.namespace !== 'core')
      for (const block of customBlocks) {
        const renderer = generateGenericBlockRenderer(block)
        generatedComponents.push({
          ...renderer,
          description: `Custom ${block.name} block renderer (used ${block.count} times)`
        })
      }
    }

    return jsonResult({
      summary: {
        totalComponents: generatedComponents.length,
        coreBlockRenderers: includeCore ? detectedBlocks.filter(b => b.namespace === 'core').length : 0,
        customBlockRenderers: includeCustom ? detectedBlocks.filter(b => b.namespace !== 'core').length : 0,
        blocksAnalyzed: detectedBlocks.length,
        contentScanned: allContent.length
      },
      instructions: [
        'Create these files in your Nuxt project\'s components/blocks/ directory',
        'Import and use BlockRenderer to render WordPress block content',
        'Customize individual block renderers to match your design',
        'Add new block mappings to BlockRenderer.vue for custom blocks'
      ],
      detectedBlocks: detectedBlocks.map(b => ({
        name: b.name,
        count: b.count,
        hasRenderer: b.namespace === 'core' ? !!generateCoreBlockRenderer(b.blockName) : true
      })),
      components: generatedComponents.map(c => ({
        filename: c.filename,
        description: c.description
      })),
      generatedCode: generatedComponents.map(c =>
        `// ${c.filename}\n// ${c.description}\n\n${c.content}`
      ).join('\n\n// ===================================\n\n')
    })
  }
})
