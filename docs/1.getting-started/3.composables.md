# Composables

WPNuxt automatically generates type-safe composables from your GraphQL queries. These composables follow Nuxt's data fetching patterns and provide reactive state management.

## How It Works

For each GraphQL query file (`.gql` or `.graphql`), WPNuxt generates **two composables**:

- `use{QueryName}()` - Standard version
- `useLazy{QueryName}()` - Lazy-loading version

For example, from a `Posts.gql` query, you get:

- `usePosts()`
- `useLazyPosts()`

## Basic Usage

### Standard Composables

```vue
<script setup lang="ts">
// Fetches posts during SSR, hydrates to client
const { data: posts, pending, error, refresh } = usePosts();
</script>

<template>
  <div>
    <div v-if="pending">Loading...</div>
    <div v-else-if="error">Error: {{ error.message }}</div>
    <div v-else>
      <div v-for="post in posts" :key="post.id">
        {{ post.title }}
      </div>
    </div>
  </div>
</template>
```

### Lazy Composables

Use `useLazy*` variants for non-critical content that shouldn't block navigation:

```vue
<script setup lang="ts">
// Navigation happens immediately, shows loading state
const { data: posts, pending } = useLazyPosts();
</script>

<template>
  <div>
    <div v-if="pending">Loading posts...</div>
    <PostCard v-for="post in posts" :key="post.id" :post="post" />
  </div>
</template>
```

## Return Values

All composables return a reactive object with:

| Property  | Type                          | Description                                           |
| --------- | ----------------------------- | ----------------------------------------------------- |
| `data`    | `ComputedRef<T>`              | The fetched data (reactive)                           |
| `pending` | `Ref<boolean>`                | True while fetching                                   |
| `error`   | `Ref<Error>`                  | Error object if request failed                        |
| `status`  | `Ref<AsyncDataRequestStatus>` | Request status: 'idle', 'pending', 'success', 'error' |
| `refresh` | `() => Promise<void>`         | Manually refresh the data                             |
| `execute` | `() => Promise<void>`         | Re-execute the query                                  |
| `clear`   | `() => void`                  | Clear the data and error                              |

## Passing Variables

All composables accept query variables as the first parameter:

```vue
<script setup lang="ts">
// Get a specific post by URI
const { data: post } = usePostByUri({
  uri: "/my-post-slug",
});

// Get posts by category
const { data: posts } = usePostsByCategoryName({
  categoryName: "news",
});

// Get menu by name
const { data: menu } = useMenu({
  name: "main",
});
</script>
```

## Options

Both standard and lazy composables accept an optional `options` parameter:

```typescript
interface WPContentOptions {
  lazy?: boolean; // Don't block navigation (default: false)
  server?: boolean; // Fetch on server (default: true)
  immediate?: boolean; // Fetch immediately (default: true)
  watch?: any[]; // Auto-refresh when sources change
  transform?: Function; // Transform the result
}
```

### Examples

```vue
<script setup lang="ts">
// Client-only execution (skip SSR)
const { data: posts } = usePosts(undefined, {
  server: false,
});

// Watch a reactive variable and auto-refresh
const categorySlug = ref("news");
const { data: posts } = usePosts(
  { categoryName: categorySlug },
  { watch: [categorySlug] },
);

// Transform the data
const { data: titles } = usePosts(undefined, {
  transform: (data) => data?.map((post) => post.title),
});
</script>
```

## Default Composables

WPNuxt includes these composables out of the box:

### Posts

- `usePosts()` / `useLazyPosts()` - Get all posts
- `usePostByUri()` / `useLazyPostByUri()` - Get post by URI
- `usePostById()` / `useLazyPostById()` - Get post by ID
- `usePostsByCategoryName()` / `useLazyPostsByCategoryName()` - Get posts by category name
- `usePostsByCategoryId()` / `useLazyPostsByCategoryId()` - Get posts by category ID

### Pages

- `usePages()` / `useLazyPages()` - Get all pages
- `usePageByUri()` / `useLazyPageByUri()` - Get page by URI
- `usePageById()` / `useLazyPageById()` - Get page by ID

### Other

- `useMenu()` / `useLazyMenu()` - Get navigation menu
- `useNodeByUri()` / `useLazyNodeByUri()` - Get any content by URI
- `useGeneralSettings()` / `useLazyGeneralSettings()` - Get site settings
- `useViewer()` / `useLazyViewer()` - Get current user info
- `useRevisions()` / `useLazyRevisions()` - Get content revisions

## When to Use Lazy

Use **lazy variants** (`useLazy*`) for:

✅ Below-the-fold content
✅ Comments sections
✅ Related posts
✅ User activity feeds
✅ Non-critical widgets
✅ Content that loads slowly

Use **standard variants** for:

✅ Hero/main content
✅ Above-the-fold data
✅ Essential page information
✅ Fast-loading queries

## With `await` Keyword

> **Note:** Using `await` with these composables is optional and makes no functional difference, as they return reactive objects (not Promises).

Both of these work identically:

```typescript
// With await (cosmetic, no functional difference)
const { data: posts } = await usePosts();

// Without await (same behavior)
const { data: posts } = usePosts();
```

## Auto-Import

All generated composables are automatically imported - no need to import them manually:

```vue
<script setup lang="ts">
// ✅ Just use them directly
const { data: posts } = usePosts();

// ❌ No need to import
// import { usePosts } from '#wpnuxt'
</script>
```

## TypeScript Support

All composables are fully typed based on your GraphQL schema:

```typescript
import type { PostFragment } from "#graphql-operations";

const { data: posts } = usePosts();
// posts is typed as: ComputedRef<PostFragment[] | undefined>

const { data: post } = usePostById({ id: "123" });
// post is typed as: ComputedRef<PostFragment | undefined>
```

## Error Handling

Handle errors gracefully using the `error` ref:

```vue
<script setup lang="ts">
const { data: posts, error, refresh } = usePosts();

// Watch for errors
watch(error, (err) => {
  if (err) {
    console.error("Failed to load posts:", err);
  }
});
</script>

<template>
  <div>
    <div v-if="error" class="error">
      <p>{{ error.message }}</p>
      <button @click="refresh">Retry</button>
    </div>
    <div v-else>
      <!-- Your content -->
    </div>
  </div>
</template>
```

## Refreshing Data

Use `refresh()` to manually re-fetch data:

```vue
<script setup lang="ts">
const { data: posts, refresh, pending } = usePosts();

async function handleRefresh() {
  await refresh();
  console.log("Data refreshed!");
}
</script>

<template>
  <div>
    <button @click="handleRefresh" :disabled="pending">Refresh Posts</button>
  </div>
</template>
```

## Reactive Variables

Make queries reactive by watching variables:

```vue
<script setup lang="ts">
const route = useRoute();

// Automatically refetches when route.params.slug changes
const { data: post } = usePostByUri(
  { uri: route.params.slug },
  { watch: [() => route.params.slug] },
);
</script>
```

## Next Steps

- Learn about [extending queries](./4.extending-queries.md)
- Check out [performance tips](../2.advanced/1.performance.md)
- Explore [custom queries](../2.advanced/2.custom-queries.md)
