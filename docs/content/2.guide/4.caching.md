---
title: Caching
description: Optimize performance with multi-layer caching
---

# Caching

WPNuxt provides multiple layers of caching to optimize performance and reduce redundant requests.

## Cache Layers

| Layer | Scope | Duration | Purpose |
|-------|-------|----------|---------|
| Server (Nitro) | All users | Configurable | Cache GraphQL responses server-side |
| Client (GraphQL) | Per browser | Session | Deduplicate identical queries during navigation |
| Payload | Per request | Hydration | Prevent refetch after SSR |

All layers work together automatically.

## Server-Side Caching

WPNuxt caches GraphQL responses server-side using Nitro route rules.

### How It Works

1. First request fetches from WordPress (~200-500ms)
2. Response is cached on the server
3. Subsequent requests use cache (~1-5ms)
4. With SWR enabled, stale content serves instantly while refreshing in background

### Configuration

```ts [nuxt.config.ts]
wpNuxt: {
  cache: {
    enabled: true,   // Default: true
    maxAge: 300,     // Default: 300 (5 minutes)
    swr: true        // Default: true
  }
}
```

| Option | Default | Description |
|--------|---------|-------------|
| `enabled` | `true` | Enable/disable caching |
| `maxAge` | `300` | Cache duration in seconds |
| `swr` | `true` | Stale-while-revalidate |

## Client-Side Caching

WPNuxt enables client-side GraphQL caching by default. This deduplicates identical queries during client-side navigation.

### Per-Query Control

```ts
// Disable client caching for real-time data
const { data } = usePosts(undefined, { clientCache: false })

// Custom cache key for complex scenarios
const { data } = usePosts({ category: 'news' }, {
  cacheKey: `posts-news-${locale.value}`
})
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `clientCache` | `boolean` | `true` | Enable client-side caching |
| `cacheKey` | `string` | - | Custom cache key suffix |

## Payload Caching (getCachedData)

WPNuxt optimizes SSR payload handling with a smart `getCachedData` implementation:

- **During hydration**: Uses payload data (no refetch needed)
- **Watch-triggered refetches**: Uses cached data when available
- **Manual refresh**: Always fetches fresh data

### Custom getCachedData

Override the default behavior for specific use cases:

```ts
const { data } = usePosts(undefined, {
  getCachedData: (key, nuxtApp, ctx) => {
    // Always fetch fresh
    if (ctx.cause === 'refresh:manual') {
      return undefined
    }
    // Use cached data
    return nuxtApp.payload.data[key]
  }
})
```

The `ctx.cause` can be:
- `'initial'` - First load
- `'refresh:manual'` - Called `refresh()`
- `'refresh:hook'` - Triggered by Nuxt hook
- `'watch'` - Reactive dependency changed

## When to Disable Caching

### Development

```ts
// See changes immediately
wpNuxt: {
  cache: {
    enabled: false
  }
}
```

### Real-Time Content

```ts
// Per-query: disable for live data
const { data } = useLiveComments(undefined, { clientCache: false })

// Global: short cache with no SWR
wpNuxt: {
  cache: {
    maxAge: 60,
    swr: false
  }
}
```

### Authenticated Content

Authenticated requests bypass server cache automatically (via Authorization header). For user-specific data, disable client caching:

```ts
const { data } = useViewer(undefined, { clientCache: false })
```

## High-Traffic Sites

```ts
wpNuxt: {
  cache: {
    maxAge: 3600,  // 1 hour
    swr: true
  }
}
```

## Recommended Strategies

| Site Type | `maxAge` | `swr` | `clientCache` | Why |
|-----------|----------|-------|---------------|-----|
| Blog / content site | 300â€“3600 | `true` | `true` | Content changes infrequently, SWR keeps it fresh |
| News / frequently updated | 60 | `true` | `true` | Short cache + SWR = fresh content without latency |
| Dashboard / real-time | 0 | `false` | `false` | Always fetch latest data |
| E-commerce catalog | 300 | `true` | `true` | Product data is mostly stable |

## Cache Invalidation

### Manual Refresh

```ts
const { data, refresh } = usePosts()

// Force fresh data
await refresh()
```

### Reactive Invalidation

```ts
const category = ref('news')
const { data } = usePosts(
  { categoryName: category },
  { watch: [category] }
)

// Changing category triggers refetch
category.value = 'tech'
```

### Server Cache

Server cache automatically expires based on `maxAge`. For immediate invalidation, you'll need to implement a webhook from WordPress or use a CDN with cache purge capabilities.
