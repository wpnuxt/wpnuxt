# Composables API Reference

Complete API reference for WPNuxt composables.

## Type Signatures

### Standard Composables

```typescript
function use{QueryName}<T>(
  params?: QueryVariables,
  options?: WPContentOptions
): WPContentResult<T>
```

### Lazy Composables

```typescript
function useLazy{QueryName}<T>(
  params?: QueryVariables,
  options?: WPContentOptions
): WPContentResult<T>
```

> **Note:** Lazy composables are identical to standard composables with `{ lazy: true }` option pre-applied.

## WPContentOptions

```typescript
interface WPContentOptions {
  /**
   * Whether to resolve the async function after loading the route,
   * instead of blocking client-side navigation.
   * @default false
   */
  lazy?: boolean;

  /**
   * Whether to fetch data on the server (during SSR).
   * @default true
   */
  server?: boolean;

  /**
   * Whether to fetch immediately.
   * @default true
   */
  immediate?: boolean;

  /**
   * Watch reactive sources to auto-refresh.
   */
  watch?: any[];

  /**
   * Transform function to alter the result.
   */
  transform?: (input: any) => any;

  /**
   * Additional options passed to useAsyncGraphqlQuery.
   */
  [key: string]: any;
}
```

## WPContentResult

```typescript
interface WPContentResult<T> {
  /**
   * The fetched data (reactive computed ref).
   */
  data: ComputedRef<T | undefined>;

  /**
   * Whether the request is currently pending.
   */
  pending: Ref<boolean>;

  /**
   * Manually refresh the data.
   */
  refresh: () => Promise<void>;

  /**
   * Re-execute the query.
   */
  execute: () => Promise<void>;

  /**
   * Clear the data and error state.
   */
  clear: () => void;

  /**
   * Error object if the request failed.
   */
  error: Ref<Error | undefined>;

  /**
   * Current request status.
   */
  status: Ref<AsyncDataRequestStatus>;
}
```

### AsyncDataRequestStatus

```typescript
type AsyncDataRequestStatus = "idle" | "pending" | "success" | "error";
```

## Option Details

### `lazy: boolean`

Controls whether the composable uses Vue Suspense to block navigation.

**Default:** `false`

**Behavior:**

- `false` - Uses Suspense during client-side navigation (may delay route change)
- `true` - No Suspense, navigation happens immediately

**Example:**

```typescript
// Standard - uses Suspense
const { data } = usePosts();

// Lazy - no Suspense (same as useLazyPosts)
const { data } = usePosts(undefined, { lazy: true });

// Lazy variant (recommended)
const { data } = useLazyPosts();
```

### `server: boolean`

Controls whether data is fetched during server-side rendering.

**Default:** `true`

**Behavior:**

- `true` - Fetches during SSR, data available on initial render
- `false` - Skips SSR, only fetches on client

**Example:**

```typescript
// SSR + client (default)
const { data } = usePosts();

// Client-only (skips SSR)
const { data } = usePosts(undefined, { server: false });
```

**Use cases for `server: false`:**

- User-specific data (authentication required)
- Data that should only load on client
- Reducing SSR payload size
- Browser-only APIs

### `immediate: boolean`

Controls whether the query executes immediately.

**Default:** `true`

**Behavior:**

- `true` - Fetches immediately on component mount
- `false` - Requires manual execution via `execute()`

**Example:**

```typescript
// Auto-fetch (default)
const { data } = usePosts();

// Manual execution
const { data, execute } = usePosts(undefined, { immediate: false });

// Later...
await execute();
```

### `watch: any[]`

Array of reactive sources to watch. When any source changes, the query re-executes.

**Default:** `undefined`

**Example:**

```typescript
const route = useRoute();
const categorySlug = ref("news");

// Re-fetch when route params change
const { data: post } = usePostByUri(
  { uri: route.params.slug },
  { watch: [() => route.params.slug] },
);

// Re-fetch when reactive ref changes
const { data: posts } = usePostsByCategoryName(
  { categoryName: categorySlug },
  { watch: [categorySlug] },
);
```

### `transform: Function`

Function to transform the data before it's returned.

**Default:** `undefined`

**Example:**

```typescript
// Extract just titles
const { data: titles } = usePosts(undefined, {
  transform: (posts) => posts?.map((p) => p.title),
});

// Add computed properties
const { data: posts } = usePosts(undefined, {
  transform: (posts) =>
    posts?.map((p) => ({
      ...p,
      fullUrl: `https://example.com${p.uri}`,
    })),
});
```

## Method Details

### `refresh()`

Manually re-fetch the data.

**Returns:** `Promise<void>`

**Example:**

```typescript
const { data, refresh } = usePosts();

// Refresh on button click
async function handleRefresh() {
  await refresh();
}
```

**Difference from `execute()`:**

- `refresh()` - Always fetches fresh data, bypasses cache
- `execute()` - May use cached data if available

### `execute()`

Re-execute the query.

**Returns:** `Promise<void>`

**Example:**

```typescript
const { data, execute, pending } = usePosts(undefined, {
  immediate: false,
});

// Execute manually
async function loadData() {
  await execute();
}
```

### `clear()`

Clear the data and error state.

**Returns:** `void`

**Example:**

```typescript
const { data, error, clear } = usePosts();

function handleLogout() {
  clear(); // Clear cached data
}
```

## Query Variables

Each composable accepts query-specific variables as the first parameter. These are typed based on your GraphQL schema.

### Common Examples

```typescript
// No variables
const { data: posts } = usePosts();

// With pagination
const { data: posts } = usePosts({
  first: 10,
  after: "cursor",
});

// By ID
const { data: post } = usePostById({
  id: "123",
});

// By URI
const { data: post } = usePostByUri({
  uri: "/my-post-slug",
});

// By category
const { data: posts } = usePostsByCategoryName({
  categoryName: "news",
  first: 5,
});

// Menu
const { data: menu } = useMenu({
  name: "main",
  idType: "NAME",
});
```

## TypeScript Types

All types are auto-generated from your GraphQL schema:

```typescript
import type {
  PostFragment,
  PageFragment,
  MenuItemFragment,
  PostsQueryVariables,
  MenuQueryVariables,
} from "#graphql-operations";

// Strongly typed
const { data: posts } = usePosts();
// posts: ComputedRef<PostFragment[] | undefined>

const { data: menu } = useMenu({ name: "main" });
// menu: ComputedRef<MenuItemFragment[] | undefined>
```

## Advanced Patterns

### Conditional Fetching

```typescript
const route = useRoute();
const shouldFetch = computed(() => !!route.params.slug);

const { data: post } = usePostByUri(
  { uri: route.params.slug },
  {
    immediate: shouldFetch.value,
    watch: [shouldFetch],
  },
);
```

### Combining Multiple Queries

```typescript
const { data: posts } = usePosts();
const { data: pages } = usePages();

const allContent = computed(() => [
  ...(posts.value || []),
  ...(pages.value || []),
]);
```

### Dependent Queries

```typescript
const { data: post } = usePostById({ id: "123" });

// Wait for first query, then fetch related
const relatedPosts = computed(() => {
  if (!post.value?.categories) return [];
  return post.value.categories[0]?.slug;
});

const { data: categoryPosts } = usePostsByCategoryName(
  { categoryName: relatedPosts },
  { watch: [relatedPosts] },
);
```

### Polling

```typescript
const { refresh } = usePosts();

// Poll every 30 seconds
const pollInterval = setInterval(() => {
  refresh();
}, 30000);

onUnmounted(() => {
  clearInterval(pollInterval);
});
```

## Performance Tips

1. **Use lazy variants** for below-fold content
2. **Set `server: false`** for user-specific data
3. **Use `watch`** instead of manual refresh for reactive data
4. **Clear unused data** with `clear()` on unmount
5. **Transform data** to reduce memory footprint

## See Also

- [Composables Guide](../1.getting-started/3.composables.md)
- [Performance Best Practices](./1.performance.md)
- [Custom Queries](./3.custom-queries.md)
