# Migration Guide

This guide helps you migrate from the old WPNuxt API to the new composables-based API.

## Overview of Changes

The new API consolidates data fetching into a single, Nuxt-compatible pattern:

### Old API (Removed)

- ❌ `useWPContent()` - Synchronous version
- ❌ `useAsyncWPContent()` - Async version
- ❌ Separate functions for different behaviors

### New API (Current)

- ✅ `use{Query}()` - Standard composables
- ✅ `useLazy{Query}()` - Lazy-loading variants
- ✅ Unified API following Nuxt conventions

## Breaking Changes

### 1. Removed `useAsyncWPContent`

**Before:**

```typescript
const { data, pending, refresh } = await useAsyncWPContent(...)
```

**After:**
Use the generated composables directly:

```typescript
const { data, pending, refresh } = usePosts();
```

### 2. Generated Composables Replace Manual Calls

**Before:**

```typescript
// Manual query name and nodes
const { data } = await useWPContent("Posts", ["posts", "nodes"], false);
```

**After:**

```typescript
// Auto-generated type-safe composable
const { data: posts } = usePosts();
```

### 3. Data is Now a ComputedRef

**Before:**

```typescript
const { data } = await useWPContent(...)
// data was a plain value or undefined
console.log(data?.title)
```

**After:**

```typescript
const { data: post } = usePostById({ id: "123" });
// data is a ComputedRef, access with .value in script
console.log(post.value?.title);

// In template, .value is automatic:
// <h1>{{ post.title }}</h1>
```

### 4. Return Value Structure

**Before:**

```typescript
const { data } = await useWPContent(...)
// Returns: { data: T | undefined }
```

**After:**

```typescript
const { data, pending, error, refresh, execute, clear, status } = usePosts();
// Returns full AsyncData-style object
```

## Migration Steps

### Step 1: Replace `useAsyncWPContent` Calls

**Before:**

```vue
<script setup lang="ts">
const { data: posts, pending } = await useAsyncWPContent(
  "Posts",
  ["posts", "nodes"],
  false,
);
</script>
```

**After:**

```vue
<script setup lang="ts">
// Use the auto-generated composable
const { data: posts, pending } = usePosts();
</script>
```

### Step 2: Update Data Access

**Before:**

```vue
<script setup lang="ts">
const { data } = await useWPContent("PostById", ["post"], false, { id: "123" });
// data is directly usable
const title = data?.title;
</script>
```

**After:**

```vue
<script setup lang="ts">
const { data: post } = usePostById({ id: "123" });
// In script, use .value
const title = computed(() => post.value?.title);

// Or directly in template (no .value needed)
</script>

<template>
  <h1>{{ post?.title }}</h1>
</template>
```

### Step 3: Replace Manual Query Names

Find all instances of manual query names and replace with generated composables:

| Old Query Name | New Composable   |
| -------------- | ---------------- |
| `'Posts'`      | `usePosts()`     |
| `'PostById'`   | `usePostById()`  |
| `'PostByUri'`  | `usePostByUri()` |
| `'Pages'`      | `usePages()`     |
| `'PageByUri'`  | `usePageByUri()` |
| `'Menu'`       | `useMenu()`      |

### Step 4: Update Error Handling

**Before:**

```typescript
try {
  const { data } = await useAsyncWPContent(...)
} catch (error) {
  console.error(error)
}
```

**After:**

```typescript
const { data, error } = usePosts();

// Watch for errors
watch(error, (err) => {
  if (err) console.error(err);
});

// Or in template
```

```vue
<template>
  <div v-if="error">Error: {{ error.message }}</div>
</template>
```

### Step 5: Update Loading States

**Before:**

```vue
<script setup lang="ts">
const { data, pending } = await useAsyncWPContent(...)
</script>

<template>
  <div v-if="pending">Loading...</div>
  <div v-else>{{ data }}</div>
</template>
```

**After:**

```vue
<script setup lang="ts">
const { data: posts, pending } = usePosts();
</script>

<template>
  <div v-if="pending">Loading...</div>
  <div v-else>
    <div v-for="post in posts" :key="post.id">
      {{ post.title }}
    </div>
  </div>
</template>
```

## Common Migration Patterns

### Pattern 1: Simple Data Fetch

**Before:**

```typescript
const { data } = await useWPContent("Posts", ["posts", "nodes"], false);
```

**After:**

```typescript
const { data: posts } = usePosts();
```

### Pattern 2: With Parameters

**Before:**

```typescript
const { data } = await useWPContent("PostByUri", ["nodeByUri"], false, {
  uri: "/my-post",
});
```

**After:**

```typescript
const { data: post } = usePostByUri({
  uri: "/my-post",
});
```

### Pattern 3: Lazy Loading

**Before:**

```typescript
// No direct equivalent - required manual handling
const { data } = await useAsyncWPContent("Posts", ["posts", "nodes"], false);
```

**After:**

```typescript
// Built-in lazy variant
const { data: posts, pending } = useLazyPosts();
```

### Pattern 4: Client-Only Fetching

**Before:**

```typescript
// Had to manually check if on client
if (process.client) {
  const { data } = await useAsyncWPContent(...)
}
```

**After:**

```typescript
// Built-in option
const { data: posts } = usePosts(undefined, {
  server: false,
});
```

### Pattern 5: Refreshing Data

**Before:**

```typescript
const { data, refresh } = await useAsyncWPContent(...)
await refresh()
```

**After:**

```typescript
const { data: posts, refresh } = usePosts();
await refresh();
// Same API!
```

## TypeScript Migration

### Before: Manual Types

```typescript
import type { PostFragment } from "#graphql-operations";

const { data } = await useWPContent("Posts", ["posts", "nodes"], false);
const posts = data as PostFragment[] | undefined;
```

### After: Auto-Typed

```typescript
// Types are automatic!
const { data: posts } = usePosts();
// posts is ComputedRef<PostFragment[] | undefined>
```

## Custom Queries

If you had custom queries, they now generate composables automatically:

**Before:**

```typescript
// CustomPosts.gql
query CustomPosts {
  posts { nodes { ...Post } }
}

// Usage:
const { data } = await useWPContent('CustomPosts', ['posts', 'nodes'], false)
```

**After:**

```typescript
// CustomPosts.gql (same file)
query CustomPosts {
  posts { nodes { ...Post } }
}

// Auto-generated composables:
const { data: posts } = useCustomPosts()
const { data: posts } = useLazyCustomPosts()
```

## Troubleshooting

### Issue: `data` is undefined in script

**Problem:**

```typescript
const { data: post } = usePostById({ id: "123" });
console.log(post.title); // ❌ undefined
```

**Solution:**

```typescript
const { data: post } = usePostById({ id: "123" });
console.log(post.value?.title); // ✅ Use .value

// Or use computed
const title = computed(() => post.value?.title);
```

### Issue: Can't find composable

**Problem:**

```typescript
const { data } = usePosts(); // ❌ Not found
```

**Solution:**

1. Make sure your `.gql` file exists
2. Run `pnpm run dev:prepare` to regenerate
3. Check the query name matches (case-sensitive)

### Issue: Types not working

**Problem:**

```typescript
const { data: posts } = usePosts();
// posts has type 'any'
```

**Solution:**

1. Run `pnpm run dev:prepare` to regenerate types
2. Restart TypeScript server in your IDE
3. Check `graphql-operations.d.ts` exists

## Need Help?

If you encounter issues during migration:

1. Check the [Composables Guide](../1.getting-started/3.composables.md)
2. Review the [API Reference](./2.composables-api.md)
3. Open an issue on [GitHub](https://github.com/wpnuxt/wpnuxt-core/issues)

## Rollback (Not Recommended)

If you need to temporarily rollback, you can pin to the old version:

```json
{
  "dependencies": {
    "wpnuxt": "^0.x.x"
  }
}
```

However, we strongly recommend migrating to the new API for better type safety, DX, and future compatibility.
